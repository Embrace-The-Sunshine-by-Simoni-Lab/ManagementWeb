{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.endOfRange = endOfRange;\nexports.eventSegments = eventSegments;\nexports.eventLevels = eventLevels;\nexports.inRange = inRange;\nexports.segsOverlap = segsOverlap;\nexports.sortEvents = sortEvents;\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction endOfRange(_ref) {\n  var dateRange = _ref.dateRange,\n      _ref$unit = _ref.unit,\n      unit = _ref$unit === void 0 ? 'day' : _ref$unit,\n      localizer = _ref.localizer;\n  return {\n    first: dateRange[0],\n    last: localizer.add(dateRange[dateRange.length - 1], 1, unit)\n  };\n} // properly calculating segments requires working with dates in\n// the timezone we're working with, so we use the localizer\n\n\nfunction eventSegments(event, range, accessors, localizer) {\n  var _endOfRange = endOfRange({\n    dateRange: range,\n    localizer: localizer\n  }),\n      first = _endOfRange.first,\n      last = _endOfRange.last;\n\n  var slots = localizer.diff(first, last, 'day');\n  var start = localizer.max(localizer.startOf(accessors.start(event), 'day'), first);\n  var end = localizer.min(localizer.ceil(accessors.end(event), 'day'), last);\n  var padding = (0, _findIndex.default)(range, function (x) {\n    return localizer.isSameDate(x, start);\n  });\n  var span = localizer.diff(start, end, 'day');\n  span = Math.min(span, slots); // The segmentOffset is necessary when adjusting for timezones\n  // ahead of the browser timezone\n\n  span = Math.max(span - localizer.segmentOffset, 1);\n  return {\n    event: event,\n    span: span,\n    left: padding + 1,\n    right: Math.max(padding + span, 1)\n  };\n}\n\nfunction eventLevels(rowSegments, limit) {\n  if (limit === void 0) {\n    limit = Infinity;\n  }\n\n  var i,\n      j,\n      seg,\n      levels = [],\n      extra = [];\n\n  for (i = 0; i < rowSegments.length; i++) {\n    seg = rowSegments[i];\n\n    for (j = 0; j < levels.length; j++) {\n      if (!segsOverlap(seg, levels[j])) break;\n    }\n\n    if (j >= limit) {\n      extra.push(seg);\n    } else {\n      ;\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n  }\n\n  for (i = 0; i < levels.length; i++) {\n    levels[i].sort(function (a, b) {\n      return a.left - b.left;\n    }); //eslint-disable-line\n  }\n\n  return {\n    levels: levels,\n    extra: extra\n  };\n}\n\nfunction inRange(e, start, end, accessors, localizer) {\n  var event = {\n    start: accessors.start(e),\n    end: accessors.end(e)\n  };\n  var range = {\n    start: start,\n    end: end\n  };\n  return localizer.inEventRange({\n    event: event,\n    range: range\n  });\n}\n\nfunction segsOverlap(seg, otherSegs) {\n  return otherSegs.some(function (otherSeg) {\n    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;\n  });\n}\n\nfunction sortEvents(eventA, eventB, accessors, localizer) {\n  var evtA = {\n    start: accessors.start(eventA),\n    end: accessors.end(eventA),\n    allDay: accessors.allDay(eventA)\n  };\n  var evtB = {\n    start: accessors.start(eventB),\n    end: accessors.end(eventB),\n    allDay: accessors.allDay(eventB)\n  };\n  return localizer.sortEvents({\n    evtA: evtA,\n    evtB: evtB\n  });\n}","map":{"version":3,"sources":["/Users/zhaoyuliu/Desktop/matx-basic/node_modules/react-big-calendar/lib/utils/eventLevels.js"],"names":["_interopRequireDefault","require","exports","__esModule","endOfRange","eventSegments","eventLevels","inRange","segsOverlap","sortEvents","_findIndex","_ref","dateRange","_ref$unit","unit","localizer","first","last","add","length","event","range","accessors","_endOfRange","slots","diff","start","max","startOf","end","min","ceil","padding","default","x","isSameDate","span","Math","segmentOffset","left","right","rowSegments","limit","Infinity","i","j","seg","levels","extra","push","sort","a","b","e","inEventRange","otherSegs","some","otherSeg","eventA","eventB","evtA","allDay","evtB"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.endOfRange = endOfRange;\nexports.eventSegments = eventSegments;\nexports.eventLevels = eventLevels;\nexports.inRange = inRange;\nexports.segsOverlap = segsOverlap;\nexports.sortEvents = sortEvents;\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction endOfRange(_ref) {\n  var dateRange = _ref.dateRange,\n      _ref$unit = _ref.unit,\n      unit = _ref$unit === void 0 ? 'day' : _ref$unit,\n      localizer = _ref.localizer;\n  return {\n    first: dateRange[0],\n    last: localizer.add(dateRange[dateRange.length - 1], 1, unit)\n  };\n} // properly calculating segments requires working with dates in\n// the timezone we're working with, so we use the localizer\n\n\nfunction eventSegments(event, range, accessors, localizer) {\n  var _endOfRange = endOfRange({\n    dateRange: range,\n    localizer: localizer\n  }),\n      first = _endOfRange.first,\n      last = _endOfRange.last;\n\n  var slots = localizer.diff(first, last, 'day');\n  var start = localizer.max(localizer.startOf(accessors.start(event), 'day'), first);\n  var end = localizer.min(localizer.ceil(accessors.end(event), 'day'), last);\n  var padding = (0, _findIndex.default)(range, function (x) {\n    return localizer.isSameDate(x, start);\n  });\n  var span = localizer.diff(start, end, 'day');\n  span = Math.min(span, slots); // The segmentOffset is necessary when adjusting for timezones\n  // ahead of the browser timezone\n\n  span = Math.max(span - localizer.segmentOffset, 1);\n  return {\n    event: event,\n    span: span,\n    left: padding + 1,\n    right: Math.max(padding + span, 1)\n  };\n}\n\nfunction eventLevels(rowSegments, limit) {\n  if (limit === void 0) {\n    limit = Infinity;\n  }\n\n  var i,\n      j,\n      seg,\n      levels = [],\n      extra = [];\n\n  for (i = 0; i < rowSegments.length; i++) {\n    seg = rowSegments[i];\n\n    for (j = 0; j < levels.length; j++) {\n      if (!segsOverlap(seg, levels[j])) break;\n    }\n\n    if (j >= limit) {\n      extra.push(seg);\n    } else {\n      ;\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n  }\n\n  for (i = 0; i < levels.length; i++) {\n    levels[i].sort(function (a, b) {\n      return a.left - b.left;\n    }); //eslint-disable-line\n  }\n\n  return {\n    levels: levels,\n    extra: extra\n  };\n}\n\nfunction inRange(e, start, end, accessors, localizer) {\n  var event = {\n    start: accessors.start(e),\n    end: accessors.end(e)\n  };\n  var range = {\n    start: start,\n    end: end\n  };\n  return localizer.inEventRange({\n    event: event,\n    range: range\n  });\n}\n\nfunction segsOverlap(seg, otherSegs) {\n  return otherSegs.some(function (otherSeg) {\n    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;\n  });\n}\n\nfunction sortEvents(eventA, eventB, accessors, localizer) {\n  var evtA = {\n    start: accessors.start(eventA),\n    end: accessors.end(eventA),\n    allDay: accessors.allDay(eventA)\n  };\n  var evtB = {\n    start: accessors.start(eventB),\n    end: accessors.end(eventB),\n    allDay: accessors.allDay(eventB)\n  };\n  return localizer.sortEvents({\n    evtA: evtA,\n    evtB: evtB\n  });\n}"]},"metadata":{},"sourceType":"script"}